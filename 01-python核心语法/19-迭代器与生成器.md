# 迭代器与生成器

## 1. 迭代器

迭代：每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。例如：循环获取容器中的元素。

> 单纯的重复并不是迭代

- 可迭代对象：从语法形式上讲，内置有`__iter__`方法的对象都是可迭代对象，字符串、列表、元组、字典、集合都是可迭代对象
- 调用`__iter__`方法返回的结果就是一个迭代器对象(Iterator)。迭代器对象是内置有`__iter__`和`__next__`方法的对象
  - 执行迭代器对象`__iter__`方法得到的仍然是迭代器本身
  - 而执行迭代器`__next__`方法就会计算出迭代器中的下一个值。
  - 迭代器是Python提供的一种统一的、不依赖于索引的迭代取值方式，只要存在多个“值”，无论序列类型还是非序列类型都可以按照迭代器的方式取值
- for循环原理
  - for循环又称为迭代循环，in后可以跟任意可迭代对象
  - for 循环在工作时，首先会调用可迭代对象内置的`__iter__`方法拿到一个迭代器对象
  - 再调用该迭代器对象的`__next__`方法将取到的值赋值
  - 周而复始，直到捕捉StopIteration异常，结束迭代。
- 迭代器的优点
  - 为序列和非序列类型提供了一种统一的迭代取值方式。
  - 可以只在需要时才去调用`__next__`来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。



## 2. 生成器与yield

若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象，生成器内置有`__iter__`和`__next__`方法，所以生成器本身就是一个迭代器。我们可以用`__next__`触发生成器所对应函数的执行，

```python
def my_range(start,stop,step=1):
    while start < stop:
        yield start
        start+=step

g = my_range(0,3)
```

有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值

> 假设要让你生成 300w个随机的4位数，并打印出来。
>
> - 在内存中一次性创建300w个
>
>   ```python
>   import random
>   
>   data_list = []
>   for i in range(300000000):
>       val = random.randint(1000, 9999)
>   	data_list.append(val)
>   ```
>
> - 动态创建，用一个创建一个。
>
>   ```python
>   import random
>   
>   
>   def gen_random_num(max_count):
>       counter = 0
>       while counter < max_count:
>           yield random.randint(1000, 9999)
>           counter += 1
>   ```

