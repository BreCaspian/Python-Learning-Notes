##某音直播RPC



### RPC介绍

```stylus
RPC，全称Remote Procedure Call, 即远程过程调用。
主要作用是屏蔽网络编程细节，实现调用远程方法就像调用本地方法（同一个进程中的方法）一样的体验。
同时屏蔽底层网络通信的复杂性，让我们更加专注业务逻辑的开发。
```

### 序列化和反序列化

```stylus
网络传输的数据必须是二进制数据，但是调用方的请求的出入参数都是对象，对象是不能直接在网络中传输的，必须提前把它转换成可传输的二进制数据，这个过程就叫做“序列化”。

服务端必须要做到的是能够正确的从网络传输过来的二进制数据中分割出不同的请求，同时根据请求类型和序列化类型，把二进制的数据还原为请求对象，这个过程叫做“反序列化”。

在RPC调用中，对输入参数对象与返回值对象进行序列化和反序列化是一个必须的过程
```

### 网络通信

```stylus
RPC在大多数情况下，是一个高并发的调用场景，根据系统内核的支持、编程语言的支持以及IO模型本身的特点，在RPC框架的实现中，在网络通信的处理上，大多数会选择 IO多路复用的方式
```

###正式开始

<img src="../img/rpc爬虫原理.png"></img>

```stylus
在JS中,websocket的new WebSocket()是固定的语法，可以用作我们定位的关键词
WebSocket.send  用于向服务器发送请求
WebSocket.onopen 用于指定连接成功后的回调函数
WebSocket.onmessage 用于指定收到服务器数据后的回调函数
WebSocket.onclose 用于指定连接关闭后的回调函数
WebSocket.binaryType = "arraybuffer"; 用来表示通用的，固定长度的二进制数据缓冲区

RPC最重要的是找到入口点，一般WebSocket消息处理函数为onmessage或者addEventListener("message")
```

```javascript
ws.onmessage = function(event){
    var data = event.data;
};

ws.addEventListener("message", function(event){
    var data = event.data;
});
```

### RPC的JS代码

```javascript
window.dataLx = s.toObject();
// !function为创建自执行方法
//!function(){
    // 创建局部变量，接收window.dataLx全局变量
    var res = window.dataLx;
    if (window.flagLX){
        window.wsLX.send(JSON.stringify(res));
    }
    else{
        var ws = new WebSocket("ws://127.0.0.1:9999");
        window.wsLX = ws;
        window.flagLX = true;
        ws.open = function(evt){};
        ws.onmessage = function(evt){
            ws.send(JSON.stringify(res));
        }
    }
//};
```

###python创建websocket通信

```python
import asyncio, websockets


async def check_permit(websocket):
    send_text = 'lx'
    await websocket.send(send_text)
    return True


async def recv_msg(websocket):
    while True:
        recv_text = await websocket.recv()
        print(recv_text)


async def main_logic(websocket, path):
    await check_permit(websocket)
    await recv_msg(websocket)

start_server = websockets.serve(main_logic, '127.0.0.1', 9999)
asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
```

### 应用场景拓展

```stylus
在部分有JS加密的场景中

我们可以通过socket通信，以python为服务端，浏览器为客户端，将用户的输入传递进js代码中
然后在js代码中构建请求对象，发送请求，将响应内容通过socket通信返回给python客户端执行响应的解析，从而在有翻页等循环请求的场景中，解决js加密
```


