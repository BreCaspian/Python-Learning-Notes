### 外包项目：实时数据快手弹幕采集

### 采集目标：用户id，用户名称，性别，弹幕时间，弹幕内容等数据



### 正式开始

```stylus
流程分析：
	1.开放接口：'https://livev.m.chenzhongtech.com/wap/live/feed?liveStreamId=' + '直播间live-Stream-Id'
	2.TK界面制作：
		结合ttkbootstrap官网：制作适用客户使用的可视化界面
注意：
	1.该程序是面向用户的开发，所以重点倾向于TK界面的制作
	2.结合pyinstaller的打包功能，将py文件打包成windows可执行文件<文件后缀为.exe>
	3.该可执行程序可以在没有python环境的电脑运行，方便客户的使用
```

###代码展示

```python
# -*- coding: utf-8 -*-
# @Author : 阿尔法
# @File : demo
# @Software: PyCharm
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.scrolled import ScrolledText
import tkinter.messagebox as msgbox
from threading import Thread
from requests_html import HTMLSession
# 构造请求对象
session = HTMLSession()
import time, json


class TKSpider(object):

    def __init__(self):
        self.root = ttk.Window(
            title="爬虫通用界面",  # 设置窗口的标题
            themename="solar",  # 设置主题 litera newtheme vapor cyborg solar superhero darkly
            size=(1300, 650),  # 窗口的大小
            position=(500, 200),  # 窗口所在的位置
            resizable=None,  # 设置窗口是否可以更改大小
            alpha=1.0,  # 设置窗口的透明度(0.0完全透明）
        )
        """用户得输入栏：提示"""
        self.e1 = ttk.Label(self.root, text='直播间地址:')
        self.e1.grid(row=1, column=1, sticky=ttk.W, padx=6, pady=6)
        self.e2 = ttk.Entry(self.root, show=None, width=20, bootstyle=PRIMARY, textvariable=self.e1)
        self.e2.grid(row=1, column=2, sticky=ttk.W, padx=6, pady=6)
        """定义搜索按钮"""
        self.button_2 = ttk.Button(self.root, text='搜索', bootstyle="success-outline",
                                   command=self.parse_running)
        self.button_2.grid(row=1, column=3, pady=6, padx=6)
        """定义暂停按钮"""
        self.button_3 = ttk.Button(self.root, text='暂停/继续', bootstyle="success-outline",
                                   command=self.parse_stop)
        self.button_3.grid(row=1, column=4, pady=6, padx=6)

        """定义弹幕持续获取条件"""
        self.is_running = True
        """富文本显示栏"""
        # 创建单独滚动文本框 与 Labelframe  歌词 一起
        # self.text1 = ScrolledText(self.e3, autohide=True, bootstyle="round", width=40, height=21.4)
        # self.text1.grid(row=2, column=7, columnspan=8)
        # 创建 Labelframe
        self.f = ttk.Labelframe(text="弹幕", bootstyle=PRIMARY)
        self.f.grid(row=2, column=2, columnspan=6)
        # 创建树视图 在Labelframe  一起
        self.tree = ttk.Treeview(master=self.f,
                                 columns=['1', '2', '3', '4', '5'],
                                 show='headings',
                                 height=26,
                                 )
        self.tree.grid(row=1, column=1, columnspan=6)
        self.tree.column('1', width=120, anchor='center')
        self.tree.column('2', width=200, anchor='center')
        self.tree.column('3', width=80, anchor='center')
        self.tree.column('4', width=200, anchor='center')
        self.tree.column('5', width=520, anchor='center')
        self.tree.heading('1', text='用户ID')
        self.tree.heading('2', text='用户名称')
        self.tree.heading('3', text='用户性别')
        self.tree.heading('4', text='弹幕时间')
        self.tree.heading('5', text='弹幕内容')
        # 创建滚动条 在Labelframe  一起
        self.scroll = ttk.Scrollbar(master=self.f, orient="vertical", command=self.tree, )
        # # 将滚动条填充
        self.tree.config(yscrollcommand=self.scroll.set)
        # 将滚动条与tree关联
        self.scroll['command'] = self.tree.yview
        self.scroll.grid(row=1, column=7, rowspan=20, columnspan=20, sticky=NS, )
        """弹幕过滤字典"""
        self.big_data = {}

    def parse_running(self):
        """
        添加线程关系爬虫逻辑程序
        :return:
        """
        Thread(target=self.parse_start_url).start()

    def parse_start_url(self):
        """
        爬虫主题逻辑
        :return:
        """
        # 获取用户输入
        keyword = self.e2.get()
        # 获取直播间stream_id
        try:
            response = session.get(keyword).html
            stream_id = ''.join(response.xpath('//div/@live-stream-id'))
            url = 'https://livev.m.chenzhongtech.com/wap/live/feed?liveStreamId=' + stream_id

            while self.is_running:
                time.sleep(2)
                response = session.get(url).json()
                response = json.loads(response)
                num = response['currentWatchingCount']
                self.button_4 = ttk.Button(self.root, text=f'在线人数：{num}人', bootstyle="success-outline", )
                self.button_4.grid(row=1, column=6, pady=6, padx=6)
                for i in response['liveStreamFeeds']:
                    user_id = i['author']['userId']
                    user_name = i['author']['userName']
                    user_sex = i['author']['userSex']
                    user_sex = '男' if 'M' == user_sex else '女'
                    time_stamp = int(i['time']) / 1000
                    # print(time_stamp)
                    content_time = str(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time_stamp)))
                    content_text = i['content']
                    """弹幕过滤"""
                    if i['time'] not in self.big_data:
                        self.big_data[i['time']] = [user_name, content_text]
                        self.tree.insert("", 'end', values=(user_id, user_name, user_sex, content_time, content_text))
                        # gui界面滑动条自动下拉
                        self.tree.yview_moveto(1.0)
                    else:
                        list_data = self.big_data[i['time']]
                        if (user_name in list_data) and (content_text in list_data):
                            continue
                        else:
                            self.big_data[i['time']] = [user_name, content_text]
                            self.tree.insert("", 'end', values=(user_id, user_name, user_sex, content_time, content_text))
                            # gui界面滑动条自动下拉
                            self.tree.yview_moveto(1.0)
        except:
            msgbox.showerror(title='错误', message='无效，请重新输入！')

    def parse_stop(self):
        """
        暂停/继续
        :return:
        """
        if self.is_running:
            self.is_running = False
        else:
            self.is_running = True
            Thread(target=self.parse_start_url).start()

    def mainloop(self):
        self.root.place_window_center()  # 让显现出的窗口居中
        self.root.resizable(False,False)
        self.root.mainloop()



if __name__ == '__main__':
    t = TKSpider()
    t.mainloop()
```

