# 阻塞和非阻塞

默认情况下我们编写的网络编程的代码都是阻塞的，阻塞主要体现在：accept\recv

如果想要让代码变为非阻塞，需要这样写：

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 加上就变为了非阻塞
sock.setblocking(False) 
sock.bind(('127.0.0.1', 8001))
sock.listen(5)

# 非阻塞
conn, addr = sock.accept()
# 非阻塞
client_data = conn.recv(1024)
print(client_data.decode('utf-8'))

conn.close()
sock.close()
import socket
client = socket.socket()
client.connect(('127.0.0.1', 8001))
client.send('hello1 world'.encode('utf-8'))
client.close()
```

如果代码变成了非阻塞，程序运行时一旦遇到 `accept`、`recv`就会抛出 BlockingIOError 的异常。这不是代码编写的有错误，而是原来的IO阻塞变为非阻塞之后，由于没有接收到相关的IO请求抛出的固定错误。

```python
from socket import *


server = socket(AF_INET, SOCK_STREAM)
server.bind(('127.0.0.1', 8082))
server.listen(5)
server.setblocking(False)

rlist = []
print('starting...')
while True:
    try:
        conn, addr = server.accept()
        print(addr)
        rlist.append(conn)
        print(rlist)
    except BlockingIOError as e:
        del_rlist = []
        for conn in rlist:
            try:
                data = conn.recv(1024)
                conn.send(data.upper())
            except BlockingIOError:
                continue
            except Exception:
                conn.close()
                del_rlist.append(conn)
        for conn in del_rlist:
            rlist.remove(conn)
import socket

client =s ocket.socket(socket.AF_INET,socket.SOCK_STREAM)
client.connect(('127.0.0.1',8082))

while True:
    msg = input('>>: ').strip()
    if not msg:continue
    client.send(msg.encode('utf-8'))
    data = client.recv(1024)
    print(data.decode('utf-8'))

phone.close()
```

