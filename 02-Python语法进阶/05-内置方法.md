# 内置方法

如果没有指定父类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法这些方法都是`__方法__`格式，这些方法会再某种情况下自动触发执行。我们可以在自定义类中进行重写，从而改变其行为。

- `__new__`

  ```python
  class Foo(object):
      def __new__(cls, *args, **kwargs):
          print("第一步：先创建空对象并返回")
          return object.__new__(cls)
      
      def __init__(self, name):
          print("第二步：初始化对象，在空对象中创建数据")
          self.name = name
  ```

- `__call__`

  ```python
  class Foo(object):
      def __call__(self, *args, **kwargs):
          print("执行call方法")
  
  
  obj = Foo()
  obj()
  ```

- `__str__`

  ```python
  class Foo(object):
      def __str__(self):
          return "哈哈哈哈"
  
  
  obj = Foo()
  data = str(obj)
  print(data)
  ```

- `__getitem__`、`__setitem__`、`__delitem__`

  ```python
  class Foo(object):
  
      def __getitem__(self, item):
          pass
  
      def __setitem__(self, key, value):
          pass
  
      def __delitem__(self, key):
          pass
  
  
  obj = Foo("中职通教育", 19)
  
  obj["x1"]
  obj['x2'] = 123
  del obj['x3']
  ```

- `__enter__`、`__exit__`

  ```python
  class Foo(object):
  
      def __enter__(self):
          print("进入了")
          return 666
  
      def __exit__(self, exc_type, exc_val, exc_tb):
          print("出去了")
  
  
  obj = Foo()
  with obj as data:
      print(data)
  ```

- 运算符重载

  |     方法名     |   说明   |
  | :------------: | :------: |
  |   `__add__`    |   加法   |
  |   `__sub__`    |   减法   |
  |   `__mul__`    |   乘法   |
  | `__truediv__`  |   除法   |
  | `__floodiv__`  |  地板除  |
  |   `__mod__`    |   求余   |
  |   `__pow__`    |    幂    |
  |   `__iadd__`   |    +=    |
  |   `__isub__`   |    -=    |
  |   `__imul__`   |    *=    |
  | `__itruediv__` |    /=    |
  | `__ifloodiv__` |   //=    |
  |   `__imod__`   |    %=    |
  |   `__ipow__`   |   **=    |
  |    `__lt__`    |   小于   |
  |    `__le__`    | 小于等于 |
  |    `__gt__`    |   大于   |
  |    `__ge__`    | 大于等于 |
  |    `__eq__`    |   等于   |
  |    `__ne__`    |  不等于  |

- 描述符

  - 描述符本质就是一个新式类,在这个新式类中,至少实现了`__get__(),__set__(),__delete__()`中的一个,这也被称为描述符协议

  - `__get__()`:调用一个属性时,触发

  - `__set__()`:为一个属性赋值时,触发

  - `__delete__()`:采用del删除属性时,触发

    ```python
    class Foo:
        def __get__(self, instance, owner):
            pass
        def __set__(self, instance, value):
            pass
        def __delete__(self, instance):
            pass
    ```

    > 描述符类产生的实例进行属性操作并不会触发三个方法的执行，必须把描述符定义成这个类的类属性，那么每次查找这个属性时，都会调用描述符的 `__get__()` 方法，并返回它的值；同样，每次在对该属性赋值时，也会调用 `__set__()` 方法。
    >
    > 优先级由高到底分别是 1.类属性 2.描述符 3.实例属性
    >
    > 描述符是可以实现大部分python类特性中的底层魔法,包括@classmethod,@staticmethd,@property
    >
    > ```python
    > class MyProperty:
    >  def __init__(self,func):
    >      self.func=func
    > 
    >  def __get__(self, instance, owner):
    >      if instance is None:
    >          return self
    >      return self.func(instance) 
    > 
    > class Room:
    >  def __init__(self,name,width,length):
    >      self.name=name
    >      self.width=width
    >      self.length=length
    > 
    >  @MyProperty 
    >  def area(self):
    >      return self.width * self.length
    > 
    > 
    > 
    > class StaticMethod:
    >     def __init__(self,func):
    >         self.func = func
    > 
    >     def __get__(self, instance, owner):
    >         def feedback(*args,**kwargs):
    >             return self.func(*args,**kwargs)
    >         return feedback
    > 
    > class People:
    >     @StaticMethod
    >     def say_hi(x,y,z):
    >         print('------>',x,y,z)
    > ```