# 粘包问题

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(('127.0.0.1', 8001))
sock.listen(5)
conn, addr = sock.accept()

client_data = conn.recv(1024)
print(client_data.decode('utf-8'))

conn.close()
sock.close()
```

```python
import socket

client = socket.socket()
client.connect(('127.0.0.1', 8001))

client.sendall('hello'.encode('utf-8'))
client.sendall(' world'.encode('utf-8'))

client.close()
```

解决粘包的问题

- 每次发送的消息时，都将消息划分为 头部（固定字节长度） 和 数据 两部分。例如：头部，用4个字节表示后面数据的长度。

  - 发送数据，先发送数据的长度，再发送数据（或拼接起来再发送）。
  - 接收数据，先读4个字节就可以知道自己这个数据包中的数据长度，再根据长度读取到数据。

- 对于头部需要一个数字并固定为4个字节，这个功能可以借助python的struct模块来实现

  ```python
  import struct
  v1 = struct.pack('i', 199)
  
  v2 = struct.unpack('i', v1)
  print(v2)
  ```

  ```python
  import socket
  import struct
  
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock.bind(('127.0.0.1', 8001))
  sock.listen(5)
  conn, addr = sock.accept()
  
  header1 = conn.recv(4)
  data_length1 = struct.unpack('i', header1)[0]
  has_recv_len = 0
  data1 = b""
  while True:
      length = data_length1 - has_recv_len
      if length > 1024:
          lth = 1024
  	else:
          lth = length
  	chunk = conn.recv(lth) 
      data1 += chunk
      has_recv_len += len(chunk)
      if has_recv_len == data_length1:
          break
  print(data1.decode('utf-8'))
  
  
  header2 = conn.recv(4)
  data_length2 = struct.unpack('i', header2)[0] 
  data2 = conn.recv(data_length2) 
  print(data2.decode('utf-8'))
  
  conn.close()
  sock.close()
  ```

  ```python
  import socket
  import struct
  
  client = socket.socket()
  client.connect(('127.0.0.1', 8001))
  
  
  data1 = 'hello'.encode('utf-8')
  header1 = struct.pack('i', len(data1))
  client.send(header1)
  client.send(data1)
  
  
  data2 = ' world'.encode('utf-8')
  header2 = struct.pack('i', len(data2))
  client.send(header2)
  client.send(data2)
  
  client.close()
  ```